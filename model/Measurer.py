import cv2
import numpy as np
import imutils
import math

from scipy.spatial import distance as dist
from imutils import perspective
from numpy import ndarray
from model.aliases import measurement_with_img, measurement_type


class BodyPartMeasurer:
    """
    Class measuring the body part found at the image.

    This class also creates the image representing the combination of mask and
    underlying image. Due to close relation of body part size measurement
    and image modification it implements these 2 utilities.
    """

    @staticmethod
    def take_measurement(image_src: ndarray, mask: ndarray,
                         body_part: str, pixel_spacing: float) -> measurement_with_img:
        """
        Measures the body part and produces image combination of mask and src image.

        Function calculates the measurement according to provided body part label
        and returns it along with combination image.
        Measurements for body parts are:
            - femur: its length
            - head: tuple containing circumference and BPD
            - abdomen: tuple containing circumference and roundness
            - unclassified: always 0.0

        :param image_src: source image. MUST BE RESIZED TO ORIGINAL IMAGE SIZE.
        :param mask: mask generated by the YNet network. MUST BE RESIZED TO ORIGINAL IMAGE SIZE.
        :param body_part: body part found in the image.
        :param pixel_spacing: distance between pixels in mm.
        :return: tuple containing measurement and the combined image.
        """
        measurement = (0.0, image_src)
        if body_part == 'head' or body_part == 'abdomen':
            measurement = BodyPartMeasurer.__measure_circumference(image_src, mask, body_part, pixel_spacing)
        if body_part == 'femur':
            measurement = BodyPartMeasurer.__measure_femur_box(image_src, mask, pixel_spacing)
        return measurement

    @staticmethod
    def __measure_circumference(image_src: ndarray, mask: ndarray,
                                body_part: str, pixel_size: float) -> measurement_with_img:
        out_contours = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)[0]

        if len(out_contours) == 0:
            return 0.0, image_src

        min_pred_cnt = min(out_contours, key=cv2.contourArea)
        perimeter = cv2.arcLength(min_pred_cnt, True)
        approx = cv2.approxPolyDP(min_pred_cnt, 0.004 * perimeter, True)

        if len(approx) < 5:
            return 0.0, image_src
        else:
            ellipse = cv2.fitEllipseAMS(approx)

        rgb_image = cv2.cvtColor(mask, cv2.COLOR_GRAY2RGB)
        on_black = cv2.ellipse(np.zeros_like(rgb_image), ellipse, (255, 255, 255), 1, cv2.LINE_AA)
        on_black = cv2.cvtColor(on_black, cv2.COLOR_BGR2GRAY)
        contours = cv2.findContours(on_black, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)[0]

        min_cnt = min(contours, key=cv2.contourArea)
        perimeter1 = cv2.arcLength(min_cnt, True)
        measurement = perimeter1 * pixel_size

        if body_part == 'head':
            _, (d1, d2), angle = ellipse
            r_minor = min(d1, d2) / 2
            bpd = r_minor * pixel_size * 2
            measurement = (measurement, bpd)
        else:
            (d1, d2) = ellipse[1]
            roundness = d1 / d2
            measurement = (measurement, roundness)

        # Creation of the combined image starts here.
        alpha = 0.7
        thickness = 3
        color_green = (0, 255, 0)
        color_overlay = (170, 170, 0)

        overlay = image_src.copy()
        overlay2 = image_src.copy()

        cv2.ellipse(overlay, ellipse, color_green, thickness, cv2.LINE_AA)
        cv2.drawContours(overlay2, out_contours, -1, color_overlay, -1)
        cv2.addWeighted(overlay2, 0.2, overlay, 0.8, 0)
        combined_img = cv2.addWeighted(overlay, alpha, overlay2, 1 - alpha, 0)

        if body_part == 'head':
            _, (d1, d2), angle = ellipse
            xc, yc = ellipse[0]
            r_minor = min(d1, d2) / 2
            x_top = xc + math.cos(math.radians(angle)) * r_minor
            y_top = yc + math.sin(math.radians(angle)) * r_minor
            x_bot = xc + math.cos(math.radians(angle + 180)) * r_minor
            y_bot = yc + math.sin(math.radians(angle + 180)) * r_minor
            p1 = (int(x_top), int(y_top))
            p2 = (int(x_bot), int(y_bot))
            cv2.line(combined_img, p1, p2, color_green, thickness=2, lineType=cv2.LINE_AA)

        return measurement, combined_img

    @staticmethod
    def __measure_femur_box(image_src: ndarray, mask: ndarray, pixel_size: float) -> measurement_with_img:
        contours = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)[-2]

        if len(contours) == 0:
            return 0.0, image_src

        cnt = max(contours, key=cv2.contourArea)
        box = cv2.minAreaRect(cnt)
        box = cv2.boxPoints(box) if imutils.is_cv2() else cv2.boxPoints(box)
        box = perspective.order_points(box)
        (tl, tr, br, bl) = box

        def midpoint(pt_a, pt_b):
            return int(pt_a[0] + pt_b[0]) * 0.5, int(pt_a[1] + pt_b[1]) * 0.5

        (tl_bl_x, tl_bl_y) = midpoint(tl, bl)
        (tr_br_x, tr_br_y) = midpoint(tr, br)

        measurement = dist.euclidean((tl_bl_x, tl_bl_y), (tr_br_x, tr_br_y)) * pixel_size

        # Combined image creation starts here.
        color = (0, 255, 0)
        thickness = 3
        alpha = 0.7
        p1 = (int(tl_bl_x), int(tl_bl_y))
        p2 = (int(tr_br_x), int(tr_br_y))

        overlay = image_src.copy()
        overlay2 = image_src.copy()

        cv2.drawContours(overlay2, contours, -1, color, -1)
        cv2.addWeighted(overlay2, 0.5, overlay, 0.5, 0)
        cv2.line(overlay, p1, p2, (100, 255, 255), 2)
        cv2.drawMarker(overlay, p1, color=color, thickness=thickness, markerSize=20)
        cv2.drawMarker(overlay, p2, color=color, thickness=thickness, markerSize=20)
        combined_img = cv2.addWeighted(overlay, alpha, overlay2, 1 - alpha, 0)

        return measurement, combined_img

    @staticmethod
    def measurement_to_text(measurement: measurement_type) -> str:
        return f"{0.1 * (measurement if isinstance(measurement, float) else measurement[0]):.2f} cm"
